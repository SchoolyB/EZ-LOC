module utils

import @std, @io, @strings, @arrays, @maps


// Reads over the passed in path(p) then
// returns a tuple of two [string].
// One containing file nams and the other dir name
do get_dir_content(p string) -> ([string], [string]){
	temp fs [string] = {}//files
	temp ds [string] = {}//dirs

    temp content, readErr = io.read_dir(p)

    //Handle this fucking error
    if readErr != nil{
        std.println("Error occured trying to read ${p}")
        return ds, fs
    } or len(content)  == 0 {
        std.println("No content found in provided path: ${p}")
        return ds, fs
    }

    for_each c in content {
    	if io.is_dir(c) == true{
     		arrays.append(ds, c)
     	} otherwise {arrays.append(fs, c)}
    }

    return ds, fs
}

//This worker actucally reads a file(p) and counts
//Comment lines, Code lines & Blank Lines.
//Appends those values to an array and returns.
do get_line_content_of_file(&f CodeFile) -> CodeFile{
    temp arr [u64] = {0,0,0} //[0] code count [1] = comment count [2] = blank count
    temp counter u64 = 0
    temp line string
    temp readError error
    temp throwAwayIndex int
    temp trimmedContent [string]


   	temp lines, readErr = io.read_lines(f.path)
    if readErr != nil {
        std.println("Error occured while trying to read file: ${p}")
        return f
    }

    temp lineTotal = len(lines)
    //Finding blank lines
	for_each line in lines{
	    if line == ""{
			counter += 1
		}
	}
	//Store the number of blank lines in the struct
	f.lineCount[2] = counter
	counter = 0 //reset counter state

	//Due to different file types having different comment syntax I really
	//needed to write some fucking voodoo. This takes the content of each line from io
	//trims it and stores in a new dynamic array...
	//That array will be used below for finding comments. Trust me bro...
	for_each elem in lines{
	    arrays.append(trimmedContent, trim_string(elem))
	}

	//----------------------------------Single line comments----------------------------------//
	temp currentIndex int = 0

	//Look up comment syntax by file extension using the maps in constants.ez
	//Initialize to empty strings first, then set if extension exists in map
	temp singleLineCommentToLookFor string
	temp multiLineOpenCommentToLookFor string
	temp multiLineClosingCommentToLookFor string

	if maps.contains(SingleLineCommentMap, f.extension) {
		singleLineCommentToLookFor = maps.get(SingleLineCommentMap, f.extension)
	}
	if maps.contains(MultiLineOpenMap, f.extension) {
		multiLineOpenCommentToLookFor = maps.get(MultiLineOpenMap, f.extension)
	}
	if maps.contains(MultiLineCloseMap, f.extension) {
		multiLineClosingCommentToLookFor = maps.get(MultiLineCloseMap, f.extension)
	}

	for_each line in trimmedContent {
	    temp endIndex int = len(trimmedContent)

		//Only check if we have a valid comment marker (prevents counting all lines when type is unsupported)
	    if singleLineCommentToLookFor != "" && strings.starts_with(line, singleLineCommentToLookFor){
			counter += 1
		}

		//----------------------------------Multi-line comments----------------------------------//
		line = trim_string(line)

		//Only check if we have valid comment markers (prevents counting all lines when type is unsupported)
		if multiLineOpenCommentToLookFor != "" && strings.contains(line, multiLineOpenCommentToLookFor)  {
		    counter += 1
			currentIndex = arrays.index(trimmedContent, line)
			throwAwayIndex = currentIndex
			for j in range(currentIndex, len(trimmedContent)){
			    if trimmedContent[j] == multiLineClosingCommentToLookFor{
					line = trimmedContent[j]
					currentIndex = arrays.index(trimmedContent, line)
					//Only add if we have more lines between open and close (prevents negative/overflow)
					if currentIndex > throwAwayIndex + 1 {
						counter += currentIndex - throwAwayIndex - 1
					}
				}
			}
		}
	}

	//Store the number of comment lines
	f.lineCount[1] = counter

	//get actual code lines which is just the total - comments - blanks
	if lineTotal > f.lineCount[1] + f.lineCount[2] {
		f.lineCount[0] = lineTotal - f.lineCount[1] - f.lineCount[2]
	} otherwise {
		f.lineCount[0] = 0
	}

    return f
}

//Simply returns a count of contents in the passed in path(p).
//Can be files or dir
do get_count_of_all_files(p string) -> int {
    temp _, files = get_dir_content(p)
    temp count int = 0

    return len(files)
}

do get_file_and_dir_count(p string) -> (int, int){
	temp fCount int = 0
	temp dCount int = 0

	temp content, readErr = io.read_dir(p)
	if readErr != nil {
		std.println("There was an error counting content in path: ${p}")
		return -1, -1
	} or len(content) == 0 {
		std.println("No content was found in path: ${p}")
		return -2, -2
	}

	for_each c in content {
		if io.is_dir(c) == true {
			dCount +=1
		} otherwise {
			fCount +=1
		}
	}


	return dCount, fCount
}

//Returns the number of files in a path(p) with the passed in file extension(lookingFor)
do get_count_of_specific_file_type(p string,lookingFor string) -> int {
    temp _, files = get_dir_content(p)
    temp count int = 0
    temp extension string

    for_each file in files{
        extension = get_single_file_extension(file)
        if extension == strings.lower(lookingFor) {
        	count += 1
        }
    }

    return count
}

//Returns an array of extensions(WITHOUT names) in the passed in path(p)
do get_file_extensions(p string) -> [string] {
	temp dirs, files = get_dir_content(p)
    temp arr [string]

    for_each file in files {
        arrays.append(arr, get_single_file_extension(file))
    }

    return arr
}

//Returns an array of file names(WITHOUT extensions or path prefixes) in the passed in path(p)
do get_file_names(p string) -> [string]{
    temp dirs, files = get_dir_content(p)
    temp arr [string]

    for_each file in files {
        arrays.append(arr, get_single_file_name(file))
    }

    return arr
}

do get_single_file_name(p string) -> string{
    const arr [string, 2] = strings.split(p, ".")
    return arr[0]
}

//BUG: so if we split at the '.' this means if a path is './' or '../'
// we split at first '.' NOT the '.' between a file name and extension..
//a workaround is to shift() "" from the array
do get_single_file_extension(p string) -> string{
    temp arr [string] = strings.split(p, ".")
    if len(arr) == 3 {
        arrays.shift(arr)
    }
    //std.println("DEBUG get_single_file_extension arr: ${arr}")
    return arr[1]
}

//Returns an array of "filename.extensions"
do get_full_file_names(p string) -> [string]{
	temp _ , files = get_dir_content(p)
    return files
}

do check_if_file_is_empty(file string) -> (bool, Error) {
	temp data, readErr = io.read_bytes(file)
	if readErr != nil {
		return false, panic("Error reading file ${file}")
	} or len(data) > 0 {
		return false, nil
	}

	return true, nil
}

//Feature: Add this to EZ stdlib???
//Trims right and left of passed in string(s) and returns it. String is mutated
do trim_string(&s string) -> string {
    s = strings.trim_left(strings.trim_right(s))
    return s
}

do get_file_size(p string) -> byte {
	temp size, sizeErr = io.file_size(p)
	if sizeErr != nil {
		std.println("There was an error getting file: ${p}'s size.")
	}

	return byte(size)
}

//Gets and returns CodeFileType based on the passed in extension(ext)
do get_file_type(ext string) -> CodeFileType {
	temp t CodeFileType
	if ext == maps.get(CodeFileMap,CodeFileType.C) {
		t = C
	} or ext == "c++" || ext == "cpp" { //C++ can be a .c++ file or a .cpp file....dumb
		t = CPP
	} or ext == maps.get(CodeFileMap, CodeFileType.PYTHON) {
		t = PYTHON
	}

	return t
}
