module utils

import & use @std, @io, @strings, @os
import @arrays


do get_dir_content(path string) -> [string] {
    temp content, readErr = io.read_dir(path)
    if readErr != nil{
        println("Error occured trying to read ${path}")
    } or len(content)  == 0 {
        println("No content found in provided directory${path}")
    }

    return content
}

//This worker actucally reads a file(p) and counts
//Comment lines, Code lines & Blank Lines.
//Appends those values to an array and returns.
//do get_line_content_of_file(path string, cf CodeFile) -> [u64]{
do get_line_content_of_file(path string) -> [u64]{
    temp arr [u64] = {0,0,0} //[0] code count [1] = comment count [2] = blank count
    temp counter u64 = 0
    temp line string
    temp readError error
    temp throwAwayIndex int
    temp trimmedContent [string]


   	temp lines, readErr = io.read_lines(path)
    if readErr != nil {
        println("Error occured while trying to read file: ${path}")
        return {1}
    }
    temp lineTotal = len(lines)

    //Finding blank lines
	for_each line in lines{
	    if line == ""{
			counter += 1
		}
	}
	//Store the number of blank lines in a file in arr
	arr[2] = counter
	counter = 0 //reset counter state

	//Due to different file types having different comment syntax I really
	//needed to write some fucking voodoo. This takes the content of each line from io
	//trims it and stores in a new dynamic array...
	//That array will be used below for finding comments. Trust me bro...
	for_each elem in lines{
	    arrays.append(trimmedContent, trim_string(elem))
	}

	//Finding comments
	temp currentIndex int = 0
	for_each line in trimmedContent {
	    temp endIndex int = len(trimmedContent)

		// Single line comments
	    if strings.starts_with(line, "/"){ //Hack way to count `//` comments lines
			counter += 1
		}

		line = trim_string(line)

		//Multi line
		if strings.contains(line, "/*")  {
		    counter += 1
			currentIndex = arrays.index_of(trimmedContent, line)
			throwAwayIndex = currentIndex
			for j in range(currentIndex, len(trimmedContent)){
			    if trimmedContent[j] == "*/"{
					line = trimmedContent[j]
					currentIndex = arrays.index_of(trimmedContent, line)
					counter +=  currentIndex - throwAwayIndex - 1
				}
			}
		}
	}

	//Store the number of comment lines in a file in arr
	arr[1] = counter
	counter = 0 //Reset state again

	counter = lineTotal - arr[1] - arr[2]
	arr[0] = counter

    return arr
}

//Simply returns a count of contents in the passed in path(p).
//Can be files or dir
do get_count_of_all_files(p string) -> uint {
    temp content = get_dir_content(p)
    temp count uint = 0

    for_each file in content {
        count += 1
    }

    return count
}

//Returns the number of files in a path(p) with the passed in file extension(e)
do get_count_of_specific_files(p string,e string) -> uint {
    temp content = get_dir_content(p)
    temp count uint = 0
    temp fileExt string

    for_each file in content{
        fileExt = get_single_file_extension(file)
        if fileExt == strings.lower(e) {
        count += 1
        }
    }


    return count
}

//Returns an array of extensions(WITHOUT names) in the passed in path(p)
do get_file_extensions(p string) -> [string] {
    temp content = get_dir_content(p)
    temp arr [string]

    for_each item in content {
        arrays.append(arr, get_single_file_extension(item))
    }

    return arr
}

//Returns an array of file names(WITHOUT extensions) in the passed in path(p)
do get_file_names(p string) -> [string]{
	temp content = get_dir_content(p)
    temp arr [string]

    for_each item in content {
        arrays.append(arr, get_single_file_name(item))
    }

    return arr
}

do get_single_file_name(p string) -> string{
    const arr [string, 2] = strings.split(p, ".")
    return arr[0]
}

do get_single_file_extension(p string) -> string{
    const arr [string, 2] = strings.split(p, ".")
    return arr[1]
}

//Returns an array of "filename.extensions"
do get_full_file_names(path string) -> [string]{
	temp content = get_dir_content(path)
    return content
}

do check_if_file_is_empty(file string) -> (bool, Error){
	temp data, readErr = read_bytes(file)
	if readErr != nil {
		return false, panic("Error reading file ${file}")
	} or len(data) > 0 {
		return false, nil
	}

	return true, nil
}

//Trims right and left of passed in string(s) and returns it. String is mutated
do trim_string(&s string) -> string {
    s = strings.trim_left(strings.trim_right(s))
    return s
}


do determine_file_single_line_comment(type CodeFileType) -> string {
    temp comment string

    #strict
    when type{
        is C_CPP {
            comment = "//"
        }
        is PYTHON {
            comment = "#"
        }
    }


    return comment
}