module utils

import & use @std, @io, @strings, @os
import @arrays


do get_dir_content(path string) -> [string] {
    temp content, readErr = io.read_dir(path)
    if readErr != nil{
        println("Error occured trying to read ${path}")
    } or len(content)  == 0 {
        println("No content found in provided directory${path}")
    }

    return content
}

//do get_line_content_of_file(path string, t LineType ) -> [u64] {
do get_line_content_of_file(path string) {
    //temp arr u64 = {0,0,0} //[0] code count [1] = comment count [2] = blank count
    //BUG??: Cannt assign [int] to u64??? ^^^^^
    temp counter u64 = 0

   	temp lines = io.read_lines(path)
    println(lines)
    //println(typeof(lines)) //BUG: Yet another instence of Go types leaking through. lines is type: RETURN_TYPE
	for_each line in lines{//TODO: once above bug is fixed at lang level this will works
	    if line == ""{
			counter += 1
		}
	}
	println(counter)


    //#strict
    //when t{
    //    is BLANK {

    //    }
    //    default{}
    //}



}

do get_file_count(path string) -> uint {
    temp content = get_dir_content(path)
    temp count uint = 0

    for_each file in content {
        count += 1
    }

    return count
}

do get_file_extensions(path string) -> [string] {
    temp content = get_dir_content(path)
    temp arr [string]
    temp counter int = 0

    for_each item in content {
        temp splitExtArr = strings.split(item,".")
        // println(splitExtArr[1])
        arrays.append(arr, splitExtArr[1])
    }

    return arr
}

do get_file_names(path string) -> [string]{
	temp content = get_dir_content(path)
    temp arr [string]
    temp counter int = 0

    for_each item in content {
        temp splitExtArr = strings.split(item,".")
        arrays.append(arr, splitExtArr[0])
    }

    return arr
}

//returns an array of "filename.extensions"
do get_full_file_names(path string) -> [string]{
	temp content = get_dir_content(path)
    return content
}

do check_if_file_is_empty(file string) -> (bool, Error){
	temp data, readErr = read_bytes(file)
	if readErr != nil {
		return false, panic("Error reading file ${file}")
	} or len(data) > 0 {
		//TODO: //println("$File: {file} has data") //Why the fuck isnt this throwing an error at check time????
		return false, nil
	}

	return true, nil
}