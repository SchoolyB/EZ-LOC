module utils

import @std, @io, @strings, @arrays, @maps


// Reads over the passed in path(p) then
// returns a tuple of two [string].
// One containing file nams and the other dir name
do get_dir_content(p string) -> ([string], [string]){
	temp fs [string] = {}//files
	temp ds [string] = {}//dirs

    temp content, readErr = io.read_dir(p)

    //Handle this fucking error
    if readErr != nil{
        std.println("Error occured trying to read ${p}")
        return ds, fs
    } or len(content)  == 0 {
        std.println("No content found in provided path: ${p}")
        return ds, fs
    }

    for_each c in content {
    	if io.is_dir(c) == true{
     		arrays.append(ds, c)
     	} otherwise {arrays.append(fs, c)}
    }

    return ds, fs
}

//This worker actucally reads a file(p) and counts
//Comment lines, Code lines & Blank Lines.
//Appends those values to an array and returns.
//do get_line_content_of_file(path string, cf CodeFile) -> [u64]{
do get_line_content_of_file(&f CodeFile) -> CodeFile{
    temp arr [u64] = {0,0,0} //[0] code count [1] = comment count [2] = blank count
    temp counter u64 = 0
    temp line string
    temp readError error
    temp throwAwayIndex int
    temp trimmedContent [string]


   	temp lines, readErr = io.read_lines(f.path)
    if readErr != nil {
        std.println("Error occured while trying to read file: ${p}")
        return f
    }

    temp lineTotal = len(lines)
    //Finding blank lines
	for_each line in lines{
	    if line == ""{
			counter += 1
		}
	}
	//Store the number of blank lines in the struct
	f.lineCount[2] = counter
	counter = 0 //reset counter state

	//Due to different file types having different comment syntax I really
	//needed to write some fucking voodoo. This takes the content of each line from io
	//trims it and stores in a new dynamic array...
	//That array will be used below for finding comments. Trust me bro...
	for_each elem in lines{
	    arrays.append(trimmedContent, trim_string(elem))
	}

	//----------------------------------Single line comments----------------------------------//
	temp currentIndex int = 0
	for_each line in trimmedContent {
	    temp endIndex int = len(trimmedContent)
		temp singleLineCommentToLookFor string

		#strict
		when f.type{
		    is CodeFileType.C{
				singleLineCommentToLookFor = DOUBLE_SLASH
			}
			is CodeFileType.CPP{
			    singleLineCommentToLookFor = DOUBLE_SLASH
			}
			is CodeFileType.PYTHON{
			    singleLineCommentToLookFor = POUND
			}
		}

	    if strings.starts_with(line, singleLineCommentToLookFor){
			counter += 1
		}

		//----------------------------------Multi-line comments----------------------------------//
		line = trim_string(line)
		temp multiLineOpenCommentToLookFor string
		temp multiLineClosingCommentToLookFor string

		#strict
		when f.type {
		    is CodeFileType.C {
				multiLineOpenCommentToLookFor = OPENING_SLASH_STAR
				multiLineClosingCommentToLookFor = CLOSING_SLASH_STAR
			}
			is CodeFileType.CPP {
			    multiLineOpenCommentToLookFor = OPENING_SLASH_STAR
				multiLineClosingCommentToLookFor = CLOSING_SLASH_STAR
			}
			is CodeFileType.PYTHON{
			    multiLineOpenCommentToLookFor = OPENING_TRIPLE_QUOTE
				//multiLineClosingCommentToLookFor = CLOSING_TRIPLE_QOUTE
				multiLineClosingCommentToLookFor = "\"\"\""
			}
		}

		if strings.contains(line, multiLineOpenCommentToLookFor)  {
		    counter += 1
			currentIndex = arrays.index(trimmedContent, line)
			throwAwayIndex = currentIndex
			for j in range(currentIndex, len(trimmedContent)){
			    if trimmedContent[j] == multiLineClosingCommentToLookFor{
					line = trimmedContent[j]
					currentIndex = arrays.index(trimmedContent, line)
					counter +=  currentIndex - throwAwayIndex - 1
				}
			}
		}
	}

	//Store the number of comment lines in a file in arr
	f.lineCount[1] = counter
	std.println("f: ${f}") //BUG: accidentally typed: fmt.println()"Basic error printed: ERROR: module 'fmt' not imported") this needs to be addressed
	//f.lineCount[0] lineTotal - f.lineCount[1] - f.lineCount[2]

    return f
}

//Simply returns a count of contents in the passed in path(p).
//Can be files or dir
do get_count_of_all_files(p string) -> int {
    temp _, files = get_dir_content(p)
    temp count int = 0

    return len(files)
}

do get_file_and_dir_count(p string) -> (int, int){
	temp fCount int = 0
	temp dCount int = 0

	temp content, readErr = io.read_dir(p)
	if readErr != nil {
		std.println("There was an error counting content in path: ${p}")
		return -1, -1
	} or len(content) == 0 {
		std.println("No content was found in path: ${p}")
		return -2, -2
	}

	for_each c in content {
		if io.is_dir(c) == true {
			dCount +=1
		} otherwise {
			fCount +=1
		}
	}


	return dCount, fCount
}

//Returns the number of files in a path(p) with the passed in file extension(lookingFor)
do get_count_of_specific_file_type(p string,lookingFor string) -> int {
    temp _, files = get_dir_content(p)
    temp count int = 0
    temp extension string

    for_each file in files{
        extension = get_single_file_extension(file)
        if extension == strings.lower(lookingFor) {
        	count += 1
        }
    }

    return count
}

//Returns an array of extensions(WITHOUT names) in the passed in path(p)
do get_file_extensions(p string) -> [string] {
	temp dirs, files = get_dir_content(p)
    temp arr [string]

    for_each file in files {
        arrays.append(arr, get_single_file_extension(file))
    }

    return arr
}

//Returns an array of file names(WITHOUT extensions or path prefixes) in the passed in path(p)
do get_file_names(p string) -> [string]{
    temp dirs, files = get_dir_content(p)
    temp arr [string]

    for_each file in files {
        arrays.append(arr, get_single_file_name(file))
    }

    return arr
}

do get_single_file_name(p string) -> string{
    const arr [string, 2] = strings.split(p, ".")
    return arr[0]
}

do get_single_file_extension(p string) -> string{
    const arr [string, 2] = strings.split(p, ".")
    return arr[1]
}

//Returns an array of "filename.extensions"
do get_full_file_names(p string) -> [string]{
	temp _ , files = get_dir_content(p)
    return files
}

do check_if_file_is_empty(file string) -> (bool, Error) {
	temp data, readErr = io.read_bytes(file)
	if readErr != nil {
		return false, panic("Error reading file ${file}")
	} or len(data) > 0 {
		return false, nil
	}

	return true, nil
}

//Feature: Add this to EZ stdlib???
//Trims right and left of passed in string(s) and returns it. String is mutated
do trim_string(&s string) -> string {
    s = strings.trim_left(strings.trim_right(s))
    return s
}

do get_file_size(p string) -> byte {
	temp size, sizeErr = io.file_size(p)
	if sizeErr != nil {
		std.println("There was an error getting file: ${p}'s size.")
	}

	return byte(size)
}

//Gets and returns CodeFileType based on the passed in extension(ext)
do get_file_type(ext string) -> CodeFileType {
	temp t CodeFileType
	if ext == maps.get(CodeFileMap,CodeFileType.C) {
		t = C
	} or ext == "c++" || ext == "cpp" { //C++ can be a .c++ file or a .cpp file....dumb
		t = CPP
	} or ext == maps.get(CodeFileMap, CodeFileType.PYTHON) {
		t = PYTHON
	}

	return t
}
